## 문제 정의

A시스템에서 B시스템으로 XML 형태로 데이터를 연동하고, B시스템에서는 데이터 변환
과정을 거쳐 C시스템에게 XML 형태로 전달한다. B시스템의 내부 코드는 알 수 없으며,
우리가 확인할 수 있는 것은 A→B의 입력 XML과 B→C의 출력 XML뿐이다.

> 목표: 대량의 XML 입출력 데이터 쌍을 기반으로 변환 규칙을 발견하고,
> B시스템 내부 로직과 동일하게 동작하는 코드를 AI를 활용하여 자동 생성한다.


### 물리적/데이터적 구성 요소

┌──────────────┬──────────────────────────────────────────────────────────┐
│ 구성 요소     │ 세부 내용                                                │
├──────────────┼──────────────────────────────────────────────────────────┤
│ 입력 데이터   │ A→B XML: 태그명, 속성, 값, 계층 구조, 네임스페이스        │
│ 출력 데이터   │ B→C XML: 태그명, 속성, 값, 계층 구조, 네임스페이스        │
│ 변환 관계     │ 필드 매핑(1:1, 1:N, N:1), 값 변환(포맷, 계산, 조건분기),  │
│              │ 구조 변환(평탄화, 중첩화, 필터링)                          │
│ 데이터 쌍     │ (입력 XML₁, 출력 XML₁), ..., (입력 XMLₙ, 출력 XMLₙ)     │
└──────────────┴──────────────────────────────────────────────────────────┘


### 논리적 구성 요소

• 스키마 매핑: 어떤 입력 필드가 어떤 출력 필드로 가는가
• 값 변환 함수: f(입력값) → 출력값 (문자열 치환, 수식 계산, 코드 매핑, 날짜 포맷 등)
• 조건 분기 로직: if/else, switch-case에 해당하는 조건부 변환
• 집계/분배 로직: 여러 레코드를 합치거나 하나를 여러 개로 분리
• 기본값/고정값: 입력에 없지만 출력에 항상 존재하는 상수
• 순서/정렬 규칙: 출력 데이터의 정렬 기준


### 비용적 구성 요소

• 데이터 수집 및 정제 비용
• AI 모델 학습/추론 비용
• 검증 및 예외 처리 비용
• 유지보수 비용 (규칙 변경 시 재학습)


### 재정의된 문제

  > "미지의 함수 f에 대해, 대량의 (x, f(x)) 쌍이 주어졌을 때,
  >  f를 재현하는 프로그램을 자동 생성하라."
  >
  > 이것은 **프로그램 합성(Program Synthesis)** 문제이며,
  > 현대 LLM이 가장 잘하는 영역 중 하나이다.

### 아키텍처
-멀티 에이전트 최소 3개 필요할 것으로 예상(규칙 분석, 코드 생성, 생성된 코드 테스트)
-생성된 코드를 기반으로 테스트를 진행하여 결과를 검증하고 부족하면 다시 반복하는 구조
-웹서비스로 제공, MSA 구조
